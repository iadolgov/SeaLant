# SeaLant

Библиотека с инструментом для поиска утечек памяти в процессе выполнения тестов 
в Chrome или Node.js

## Установка
```
pip install sealant
```


### Инструкция

#### Пример использования

Минимальный набор действий для подключения библиотеки:
```
...

from mldlib import memleak

...

# Предназначено для использование с фреймворком UnitTests и основанных на 
# нем сторонних фреймворках
class TestsCaseExample(TestCase):

...

    # Перед тестом необходимо уже иметь запущенную ноду, библиотека
    # подключается к ней перед запуском метода test_case
    @memleak()
    def test_case(self):
        some_actions()
```
#### Параметры подключения к ноде

В представленном выше сценарии используются настройки подключения по умолчанию:
подключение к ноде по localhost:9222

При необходимости можно указать другие хост/порт ноды или прямую
ccылку websocket
```
    @memleak(host='not_localhost', port='2229', ws='ws://direct_ws:9222')
    def test_case(self):
        actions()
```
Указанный ws имеет приоритет над host/port

Допустим вариант указания настроек подключения для целого класса:
```
@memleak(host='not_localhost', port='2229')
class TestsCaseExample(TestCase):

...
    @memleak()
    def test_case(self):
        actions()
```
Можно задать настройки по умолчанию для всех использований библиотеки 
в config.py.


#### Выбор типа анализа утечки

Следующим важным этапом настройки является возможность выбора типа heapfile:
heaptimeline или heapsnapshot. По умолчанию используется heaptimeline как
более быстрый и показавший большую стабильность способ. Но для Node.js
допустим только вариант с heapsnapshot:
```
    @memleak(timeline=False)
    def test_case(self):
        actions()
```
Порядок расчета таймлайна:

1. После подключения к ноде стартует запись таймлайна
2. Метод test_case повторяется заданное в config.py количество раз
3. Дважды вызывается GC
4. Останавливается запись и расчитывается неочищенная память в каждом 
повторе (пример [500 КБ, 400 КБ, 200 КБ, 100 КБ, 1000 КБ])
5. Удаляется первый и последний повторы (в первом есть неочищаемые кучи, а в 
последнем - еще неочищенные) (пример [400 КБ, 200 КБ, 100 КБ])
6. Из обрезанного оставляется полоовина + 1 шагов, имеющих наименьшее значение
утечки (пример [200 КБ, 100 КБ])
7. Находится среднее значение оставшихся утечек (пример 150 КБ)
8. Если стоит флаг перепровки, то в случае нахождения утечки повторяются пункты 
2-7, но количество повторов метода test_case увеличивается на 2

Порядок расчета снэпшота:

1. После подключения к ноде выполняется метод test_case
2. Дважды вызывается GC
3. Снимается heapsnapshot
4. Пункты 1-3 повторяются заданное в config.py количество раз
5. В каждом heapsnapshot рассчитывается размер кучи
6. Полученные расчетные данные аппроксимируются прямой линией в зависимости от 
номера шага.
7. Рассчитывается примерная утечка памяти между двумя ближайшими точками 
(которые соответствуют номеру повтора метода test_case) аппроксимируемой 
линии
8. Если стоит флаг перепровки, то в случае нахождения утечки повторяются пункты 
1-7, но количество повторов метода test_case увеличивается на 2

Найденные утечки сравниваются с объемом, указанным в config.py (leak_size_limit).
Если размер утечки больше заданного допустимого после выполнения 8 пункта, то 
вызывается исключение LeakError.

#### Сохранение отчета и артефактов теста

В config.py можно задать, сохранять ли полученные heapfiles и составлять ли 
отчет в случае нахождения утечки. В этом случае составленный отчет и снятые 
heapfiles пакуются в zip архив и помещаются в заданную в config.py папку
(по умолчанию создается папка leaks в папке с тестом).

#### Дополнительные метрики

В библиотеке реализован сбор дополнительных метрик. Метрика - какой либо 
количественный показатель, характеризующий прирост каких либо элементов в 
процессе выполнения кода, например: размер DOM дерева и количество 
EventListeners. Метрики снимаются до и после всех действий и находится прирост. 
Значения выводятся в лог и отчет, но не исключение о наличии утечки возникает 
только при превышении допустимого объема утекшей памяти. Можно подключить Ваши 
метрики в config.py

```
func_metric_3 = "Этот код будет выполнен через Runtime.evalaute и должен вернуть" 
                "число"
# Добавить функцию в существующий кортеж
metrics = (
    ...
    (func_metric_3, "Ваш показатель")
)
```

#### Логгирование

По умолчанию используется встроенная библиотека logging, уровень сообщений info.
Однако, вы можете добавить ваш логгер в config.py:
```
from your_logger import logger_function

class MemoryLeakConfig(object):

    ...
    
    # Подставьте Вашу функцию логгирования
    logging_function = logger_function 
```

#### Функция ожидания завершения загрузки

Важным фрагментов тестирования при поиске утечек памяти является завершение 
ожидания завершения загрузки. Причем, очень часто этот момент не совпадает с
моментом прекращения сетевой активности. Поэтому в библиотека реализована
функция ожидания завершения загрузки. 

Принцип работы:
Загрузка после действия считается завершенным когда:
1. Прекратилась сетевая активность (смотрится только http запросы)
2. Перестала активно выделяться память

Наиболее полно функция работает при анализе с помощью таймлайна, так как
данный режим позволяет анализировать активность выделения памяти.

В случае снэпшотов используется только показатель сетевой активности.

1) Сетевая активность считается завершенной, когда после последнего ответа на 
уникальный запрос прошло 7 секунд. Уникальность запроса можно смотреть по какому
либо заголовку, указать который можно в config.py:
```
unique_header_name = 'unique_header' 
```
Если заголовок не найден, то уникальность определяется [RequestId](https://chromedevtools.github.io/devtools-protocol/tot/Network#type-RequestId) запроса
Сделано это для страниц, на которых никогда не прекращается сетевая активность и
есть какие либо запросы, которые посылаются с опеределенной периодичностью.

2) Активное выделение памяти считается завершенным, если за последний промежуток 
со 2 по 7 секунду от текущего момента не было выделено памяти более 10000 байт.

Все указанные настройки можно изменить в config.py:
```
time_after_last_resp = 7
heap_interval_min = 2
heap_interval_max = 7
max_heap_size = 10000
```

По умолчанию описанная функция запускается после каждого вызова метода 
test_case. Вы можете отключить ее вызов в config.py:
```
default_wait_full_load = False 
```

Также вы можете получить доступ к этой функции в test_case:
```
...

from mldlib import memleak

...

@memleak
class TestsCaseExample(TestCase):

...

    # Декорируем метод, при этом к нему привязывается аттрибут cdp
    @memleak()
    def test_case(self):
        actions()
        # Через привязанный аттрибут обращаемся к необходимой функции
        self.cdp.wait_full_load()
```

При декорировании класса к нему также привязывается аттрибут cdp, что в дальнейшем
позволяется через
``` 
class_name.cdp.wait_full_load()
``` 
получить доступ к этой функции

## Версионирование

Мы используем [SemVer](http://semver.org/) для версионирования. Доступные версии
указаны в  [tags on this repository](https://github.com/your/project/tags). 

## Authors

Докучаев С.В
    
e-mail: sv.dokuchaev@tensor.ru


Юдахин А.Е
 
e-mail: aejudakhin@gmail.com

## License

This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details

